# 汇编基础 

org 声明寻址初始地址

db   普通数据 单字节

 字符串每个字符一个字节，在加上一个停止位

jmp 占据两个字节

DW 是申请两个两个字节的内存

RESB xx 申请xx个字节的内存，并且全部初始化

MOV ax,0 把0赋值给ax寄存器

寄存器 是 一系列内存 访问很快

ax ss ds

以上寄存器大小都是两个字节

es si

0x0a 对应了 换行符

DB 0X0a, 0x0a, 申请两个字节，分别存放换行符 



```
db定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1
dw定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2
dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4 
```

字符串只能用db存储

mov al, [si]

读取的是si地址指向的内容  读取头8位的内容，也就是一个字节

ax = ah + al 16=8+8 

add si , 1 寄存器地址加一

调用系统中断， 相当于调用了操作系统的api 

一般来说 调用api 都需要参数

    mov  ah, 0x0e
    mov  bx, 15
    int  0x10


```asm
org  0x7c00;


entry:
    mov  ax, 0
    mov  ss, ax
    mov  ds, ax
    mov  es, ax
    mov  si, msg

putloop:
    mov  al, [si]
    add  si, 1
    cmp  al, 0
    je   fin
    mov  ah, 0x0e
    mov  bx, 15
    int  0x10
    jmp  putloop

fin:
    HLT
    jmp  fin

msg:
    DB    0x0a,  0x0a
    db    "hello, world"
    db    0x0a
    db    0
```



hlt 表示  halt 也就是让cpu 进入休眠状态

nasm 编译 asm代码

nasm -o boot.bat boot.asm 



# 模拟软盘读写

OsFloppy

boot2.asm

# 突破512字节

具体的做法就是做一个内核加载器，放入到第一扇区，加载器加载如内存后，再将内核从软盘加载到系统内存，然后，跳转到内核的加载地址。假定我们把编译好的内核代码写入软盘的第1柱面，第2扇区

ES:BX  ES*16+BX

boot_512.asm

kernal.asm

第一个512字节区 

```
buf[510] = 0x55;
buf[511] = (byte)0xaa;
```



# 从实模式到保护模式（难理解）

寻址范围大大增大

功能更加强大

https://www.cnblogs.com/LexMoon/p/antz02.html

https://blog.csdn.net/judyge/article/details/52344139

**https://blog.csdn.net/yihaolovem/article/details/23483927?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-1.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-1.nonecase**



实模式下寻址：段寄存器*16+偏移

1m+64k

8个字节， 前两个字节表示长度



# 保护模式寻址功能

实模式寻址最多20位 (1m) 地址总线20位

保护模式可以寻址到32位（4g)

